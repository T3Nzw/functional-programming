# Задачи

## Задача 00

Да се дефинира функция `compose`, която приема две едноместни функции
и връща нова функция, която е тяхната композиция. Какъв трябва да е типът
на `compose`?

## Задача 01

Да се дефинират следните функции от по-висок ред от стандартната библиотека (`Prelude`):

- `flip :: (a -> b -> c) -> b -> a -> c`, която приема двуместна функция и "разменя"
  реда на аргументите ѝ;
- `map :: (a -> b) -> [a] -> b`;
- `filter :: (a -> Bool) -> [a] -> [a]`;
- `foldr :: (a -> b -> b) -> b -> [a] -> b`;
- `foldl :: (b -> a -> b) -> b -> [a] -> b`;
- `all :: (a -> Bool) -> [a] -> Bool`;
- `any :: (a -> Bool) -> [a] -> Bool`;
- `concatMap :: (a -> [b]) -> [a] -> [b]`;
- `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`;
- `curry :: ((a,b) -> c) -> a -> b -> c`;
- `uncurry :: (a -> b -> c) -> (a,b) -> c`;
- `iterate :: (a -> a) -> a -> [a]`;
- `nubBy :: (a -> a -> Bool) -> [a] -> [a]`, която премахва всички повторения в списъка на база двуместен предикат;
- `unfoldr :: (b -> Maybe (a,b)) -> b -> [a]` (от `Data.List`).

Примери:

```hs
ghci> flip (-) 1 2
1
ghci> map (+1) [1,2,3]
[2,3,4]
ghci> filter odd [1..10]
[1,3,5,7,9]
ghci> foldr (+) 0 [1..10]
55
ghci> foldl (+) 0 [1..10]
55
ghci> concatMap (\x -> [x, -x]) [1,2,3]
[1,-1,2,-2,3,-3]
ghci> zipWith (+) [1,2,3] [4,5,6]
[5,7,9]
ghci> curry (\(x,y) -> (y,x)) 4 2
(2,4)
ghci> uncurry (flip (,)) (4,2)
(2,4)
ghci> take 10 $ iterate (+1) 0
[0,1,2,3,4,5,6,7,8,9]
```

## Задача 02

Да се дефинира оператор `(&) :: a -> (a -> b) -> b`, който
прави същото като оператора `$`, но наобратно.

## Задача 03

Да се дефинира оператор `(&&&)`, който приема две едноместни функции
и някакъв аргумент `x` и връща наредена двойка от резултатите
от прилагането на функциите върху `x`.

## Задача 04

Да се напише функция, която приема едноместна функция и списък
от някакви елементи и връща списък от всички неподвижни точки
на функцията в подадения интервал. Какъв е типът на функцията?

*Забележка*: Неподвижна точка на функция `f` наричаме такъв елемент
`x`, за който е вярно, че `f x == x`.

## Задача 05

Да се дефинира функцията `scanr :: (a -> b -> b) -> b -> [a] -> [b]`,
която връща "историята" от дясното свиване (`foldr`) на списъка.

## Задача 06

Да се дефинира функция, която приема списък от функции и връща
тяхната композиция. Напишете два варианта на функцията -
използвайки рекурсия и използвайки функции от по-висок ред.

## Задача 07

Да се дефинира функция, която имплементира алгоритъма за сортиране
чрез пряка селекция, използвайки само функции от по-висок ред.

## Задача 08

Да се дефинира функция, която имплементира алгоритъма за сортиране
чрез вмъкване, използвайки само функции от по-висок ред.

## Задача 09

Да се дефинира функция, която имплементира алгоритъма за бързо сортиране.

*Бонус*: Функцията да приема двуместен предикат, който да дефинира
наредбата между елементите в списъка.

## Задача 10

Да се дефинира функция, която приема едноместен предикат и списък от
елементи от произволен тип и връща индекса и стойността на първия
елемент в списъка, който удовлетворява дадения предикат.

## Задача 11

Да се дефинира функция, която приема естествено положително число `n`
и списък от числа, задаващ интервал, и връща списък от всички подинтервали
на оригиналния с дължина `n`.

## Задача 12

Да се дефинира безкраен поток от всички цели числа, като
всяко цяло число трябва да има свой индекс в потока.
