# Задачи

## Задача 00

Да се дефинира функция `compose`, която приема две едноместни функции
и връща нова функция, която е тяхната композиция. Какъв трябва да е типът
на `compose`?

## Задача 01

Да се дефинират следните функции от по-висок ред от стандартната библиотека (`Prelude`):

- `flip :: (a -> b -> c) -> b -> a -> c`, която приема двуместна функция и "разменя"
  реда на аргументите ѝ;
- `map :: (a -> b) -> [a] -> b`;
- `filter :: (a -> Bool) -> [a] -> [a]`;
- `foldr :: (a -> b -> b) -> b -> [a] -> b`;
- `foldl :: (b -> a -> b) -> b -> [a] -> b`;
- `all :: (a -> Bool) -> [a] -> Bool`;
- `any :: (a -> Bool) -> [a] -> Bool`;
- `concatMap :: (a -> [b]) -> [a] -> [b]`;
- `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`;
- `curry :: ((a,b) -> c) -> a -> b -> c`;
- `uncurry :: (a -> b -> c) -> (a,b) -> c`;
- `iterate :: (a -> a) -> a -> [a]`;
- `nub :: Eq a => [a] -> [a]`, която премахва всички повторения в списъка (от `Data.List`);
- `unfoldr :: (b -> Maybe (a,b)) -> b -> [a]` (от `Data.List`).

Примери:

```hs
ghci> flip (-) 1 2
1
ghci> map (+1) [1,2,3]
[2,3,4]
ghci> filter odd [1..10]
[1,3,5,7,9]
ghci> foldr (+) 0 [1..10]
55
ghci> foldl (+) 0 [1..10]
55
ghci> concatMap (\x -> [x, -x]) [1,2,3]
[1,-1,2,-2,3,-3]
ghci> zipWith (+) [1,2,3] [4,5,6]
[5,7,9]
ghci> curry (\(x,y) -> (y,x)) 4 2
(2,4)
ghci> uncurry (flip (,)) (4,2)
(2,4)
ghci> take 10 $ iterate (+1) 0
[0,1,2,3,4,5,6,7,8,9]
```

## Задача 02

Да се дефинира оператор `(&&&)`, който приема две едноместни функции
и някакъв аргумент `x` и връща наредена двойка от резултатите
от прилагането на функциите върху `x`.

## Задача 03

Да се напише функция, която приема едноместна функция и списък
от някакви елементи и връща списък от всички неподвижни точки
на функцията в подадения интервал. Какъв е типът на функцията?

*Забележка*: Неподвижна точка на функция `f` наричаме такъв елемент
`x`, за който е вярно, че `f x == x`.

## Задача 04

Да се дефинира функция, която приема списък от функции и връща
тяхната композиция. Напишете два варианта на функцията -
използвайки рекурсия и използвайки функции от по-висок ред.

## Задача 05

Да се дефинира функция, която имплементира алгоритъма за сортиране
чрез пряка селекция, използвайки само функции от по-висок ред.

## Задача 06

Да се дефинира функция, която имплементира алгоритъма за бързо сортиране.

*Бонус*: Функцията да приема двуместен предикат, който да дефинира
наредбата между елементите в списъка.
