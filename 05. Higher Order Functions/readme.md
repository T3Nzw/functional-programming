# Функции от по-висок ред

Тъй като Haskell е *функционален* език за програмиране,
е повече от естествено функциите да бъдат първокласни обекти
в езика (т.е. да можем да подаваме като аргументи и връщаме функции от други функции).

Функциите в Haskell са **чисти**. Това означава, че за конкретен вход
функцията винаги ще връща един и същи изход, аналогично на
математическа функция. Това е възможно, благодарение на "липсата"
на странични ефекти в Haskell (не съвсем, странични ефекти могат
да бъдат симулирани, но е една идея по-сложно от процедурните езици).

## Тип на функция

Вече сме виждали как изглеждат типовете на функциите в Haskell:

```hs
id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

zip :: [a] -> [b] -> [(a,b)]
zip [] _ = []
zip _ [] = []
zip (x:xs) (y:ys) = (x,y):zip xs ys
```

Всяка функция съдържа $n + 1$ на брой типове в своя собствен тип,
където $n \in \mathbb{N} $. Тези $n$ на брой типове указват типовете на аргументите,
които приема функцията, а последният тип е типът на връщания резултат.

Нещо повече, `->` е оператор (над типове вместо данни) в Haskell и е
дясноасоциативен. Това означава, че можем да запишем типа на дадена функция
по следния начин:

```hs
foo :: (a1 -> (a2 -> ... -> (a_n -> (a_n+1))))
```

Например,

```hs
add3 :: Int -> Int -> Int -> Int
add3 :: Int -> Int -> (Int -> Int)
add3 :: Int -> (Int -> (Int -> Int))
add3 :: (Int -> (Int -> (Int -> Int)))
```

Малко по-надолу ще разберем защо това е от значение.
Ако искаме да подадем функция като аргумент на друга функция,
то трябва да заградим типа на тази функция в скоби:

```hs
apply :: (a -> b) -> a -> b
apply f x = f x
```

В случая `apply` е функция от по-висок ред, която приема
друга функция `f :: a -> b` и аргумент `x :: a` и
прилага `f` върху `x` и връща `f x :: b`.

Бяхме видели и т.нар. ограничения над типове в полиморфни функции:

```hs
-- за да можем да сортираме списък с елементи от някакъв тип,
-- трябва да имаме дефинирана линейна наредба над стойностите
-- от този тип (Ord a)
sort :: Ord a => [a] -> [a]
```

Тези ограничения също са част от типа на функцията и
се разделят от типовете на нейните аргументи и резултат
с удебелена стрелка `=>`. Можем да имаме множество
ограничения за различни типове, например:

```hs
bar :: (Show a, Eq a, Eq b) => a -> b -> String
```

## Операторът `($)`

Понякога в Haskell се налага да имаме голямо ниво на вложеност
на скоби:

```hs
ghci> succ (succ (succ (succ (succ (succ 1)))))
7
```

В такива ситуации е много по-удобно да използваме оператора `($)`:

```hs
ghci> succ $ succ $ succ $ succ $ succ $ succ 1
```

Той има следния тип:

```hs
($) :: (a -> b) -> a -> b
```

и представлява просто прилагане на функция върху някакъв аргумент.
Тоест, `succ $ 1` (или `($) succ 1`) е напълно валиден израз.
Това, което е специално за този оператор, е, че той е **дясноасоциативен**.
Това означава, че първо се извършват всички операции отдясно на оператора
и чак след това функцията се прилага върху резултата. Тоест,

```hs
ghci> succ $ 4 + 2 * 10 + succ 16
42
```

Именно затова е много полезен при влагане на скоби.

## Ламбда функции

Ламбда функциите (или т.нар. анонимни функции в някои други езици)
са начин за дефиниране на функция, която няма име. Използваме ги,
ако не искаме да дефинираме отделна функция (защото дефиницията
би била сравнително кратка). Началото на дадена ламбда функция
се означава с `\`, след което се изреждат агрументите ѝ,
разделени с интервали. Тялото на функцията се разделя от аргументите
ѝ със `->`. Например:

```hs
ghci> let f = \x -> x + 1
ghci> f 1
2
ghci> (\x -> x + 1) 1
2
```

```hs
ghci> :t curry
curry :: ((a, b) -> c) -> a -> b -> c
ghci> curry (\(x,y) -> x * 3 + y) 4 6
18
```

## Функции от по-висок ред

Функция от по-висок ред е функция, която приема като аргумент
или връща друга функция. Това ни позволява допълнително ниво на
абстракция върху функциите, които пишем, и ги прави по-общи.
Например:

```hs
sortBy :: Ord a => (a -> a -> Bool) -> [a] -> [a]
```

`sortBy` приема двуместен предикат, който приема два аргумента
от тип `a`, за които знаем, че са сравними, и сортира
списъка на база подадения предикат. Това е много по-общо,
тъй като ни позволява ние сами да дефиниране подредбата
на елементите в списъка.

Други примери са функциите `map :: (a -> b) -> [a] -> b` и
`filter :: (a -> Bool) -> [a] -> a`. `map` приема едноместна
функция и списък от елементи и прилага тази функция върху
всеки елемент. По този начин запазва дължината на оригиналния
списък. `filter` приема едноместен предикат и премахва от списъка
всички елементи, които не удовлетворяват този предикат.
Резултатният списък е с дължина, по-малка или равна на тази на
оригиналния списък.

## Композиция на функции

Подобно на функциите в математиката, в Haskell можем да
композираме функции чрез оператора `(.)`:

```hs
add1 :: Int -> Int
add1 x = x + 1

multBy3 :: Int -> Int
multBy3 x = x * 3
```

Тогава можем да композираме горните две функции по два начина:

```hs
ghci> let f = add1 . multBy3
ghci> f 1
4
ghci> let g = multBy3 . add1
ghci> g 1
6
-- композицията е асоциативна!
ghci> (add1 . add1 . add1 . add1) 1
ghci> 5
```

## Къринг

Кърингът е процес на преобразуването на многоместна функция
в поредица от функции, всяка от които приема единствен аргумент
и връща друга функция (в частност връщаният резултат е 0-местна функция).
Тоест, нека разгледаме следната функция:

```hs
add :: Int -> Int -> Int
add x y = x + y
```

Казахме, че операторът `->` е дясноасоциативен, така че можем да
разпишем типа ѝ по следния начин:

```hs
add :: Int -> (Int -> Int)
```

Тогава можем да си мислим, че `add` приема аргумент от тип `Int`
и връща друга функция `Int -> Int`. Нещо повече, можем да използваме
ламбда функции, за да илюстрираме горното по-добре:

```hs
add :: Int -> (Int -> Int)
add x = \y -> x + y
```

Тогава аргументът `x` има тип `Int` и `add x` връща
функцията `(\y -> x + y) :: Int -> Int`.

Даже бихме могли да разпишем функцията `add` по този начин:

```hs
add :: (Int -> (Int -> Int))
add = (\x -> (\y -> x + y))
```

Разбира се, тъй като операторите имат фиксирана асоциативност,
можем да изпуснем скобите.

## Частично прилагане на функции

Частичното прилагане на функции е процес на фиксирането на
определен брой от аргументите на дадена функция. Тогава
като резултат получаваме друга функция. Това е възможно
именно заради къринга. Например:

```hs
add :: Int -> Int -> Int
add x = \y -> x + y

add1 :: Int -> Int
add1 = add 1 -- т.е. add1 e именно ламбда функцията от по-горе
```

Тъй като частичното прилагане на функции в Haskell е сравнително
често употребявано, имаме синтактична захар за него:

```hs
ghci> map add1 [1,2,3]
[2,3,4]
ghci> map (add 1) [1,2,3]
[2,3,4]
ghci> map (1 +) [1,2,3]
[2,3,4]
ghci> map (+ 1) [1,2,3] -- събирането е комутативно!
[2,3,4]
ghci> map (- 1) [1,2,3]
[0,1,2]
ghci> map (1 -) [1,2,3] -- но изваждането не е!
[0,-1,-2]
```

Тази синтактична захар работи основно за двуместни функции
или ако искаме да фиксираме първите няколко аргумента на функция.
В противен случай би трябвало да напишем ламбда функция,
за да "изолираме" конкретния аргумент (могат да бъдат и няколко)
върху който искаме да прилагаме функцията.

Причината тази синтакчина захар да работи особено добре при
двуместни функции е заради възмножността за инфиксен запис,
а оттам - за фиксиране съответно на ляв или десен аргумент.
Например:

```hs
intersect :: Eq a => [a] -> [a] -> [a]
intersect l1 l2 = filter (`elem` l1) l2
```

Или записано чрез ламбда функция:

```hs
intersect :: Eq a => [a] -> [a] -> [a]
intersect l1 l2 = filter (\x -> x `elem` l1) l2
```

Ако искаме по-сложна функция, използването на
първия запис не е толкова тривиално:

```hs
intersect3 :: Eq a => [a] -> [a] -> [a]
intersect3 l1 l2 l3 = filter (\x -> x `elem` l1 && x `elem` l2) l3
```

Бихме могли да не използваме ламбда функция. Нека видим как може да стане:

```hs
\x -> x `elem` l1 && x `elem` l2
```

Да забележим, че можем да разделим горната функция на две по-малки:

```hs
\x -> x `elem` l1 -- или просто `elem` l1
\x -> x `elem` l2 -- или просто `elem` l2
```

Сега искаме да комбинираме тези две по-малки функции,
използвайки оператора `(&&)`. Нека разгледаме типовете
на всяка от тези функции:

```hs
(`elem` l1) :: a -> Bool
(`elem` l2) :: a -> Bool
(&&) :: Bool -> Bool -> Bool
```

Тоест, за да приложим `(&&)` върху двете функции, трябва по някакъв начин
да накараме `(&&)` да приема два аргумента от тип `a -> Bool`. Нещо повече,
нека си припомним какъв е типът на `filter`:

```hs
filter :: (a -> Bool) -> [a] -> [a]
```

Тоест, `filter` приема предикат от тип `a -> Bool`. Първоначалната
ни ламбда функция имаше именно този тип. Следователно, няма да е
достатъчно да "повдигнем" само аргументите на функцията до тип `a -> Bool`,
а е необходимо и резултатът да е от този тип. Тогава искаме следния тип за `(&&)`:

```hs
liftAnd :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
```

Ще си напишем помощна функция, която прави такова повдигане:

```hs
liftB :: (Bool -> Bool -> Bool) -> (a -> Bool) -> (a -> Bool) -> (a -> Bool)
liftB f p q = \x -> p x `f` q x
```

Нека забележим, че ако заместим `p x` с `elem x l1`, `q` - с `elem x l2`
и `f` - с `&&`, то тогава получаваме именно първоначалната ни ламбда функция.

Тоест, можем да запишем `intersect3` по следния начин:

```hs
intersect3 :: Eq a => [a] -> [a] -> [a]
intersect3 l1 l2 l3 = filter (liftB (&&) (`elem` l1) (`elem` l2)) l3
```

В действителност в Haskell вече има такава функция `liftA2`, която също би
работила в случая, но имплементацията ѝ е сравнително по-сложна (макар и аналогична)
на това, което написахме по-горе.
