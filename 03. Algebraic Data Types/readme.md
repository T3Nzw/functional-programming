# Алгебрични типове данни - 21.10.2025

## Безкрайни списъци (продължение от миналия път)

В Haskell оценяването се извършва *лениво* (call-by-need).
Това означава, че даден израз се оценява едва когато
бъде използван някъде. Например, ако имаме следната дефиниция:

```hs
x = 2+5
```

Събирането няма да се извърши, докато не поискаме тази стойност:

```hs
ghci> x
7
```

Именно това лениво оценяване ни позволява да дефинираме потоци
(безкрайни списъци). Например, бихме могли да създадем безкраен
поток от всички естествени числа:

```hs
nats = [0..]
```
Тогава можем да вземем краен списъка, използвайки функции като
`head`, `take` и т.н.

```hs
ghci> take 10 nats
[0,1,2,3,4,5,6,7,8,9]
```

Бихме могли да дефинираме безкраен списък от единици, използвайки
рекурсивна дефиниция:

```hs
ones = 1:ones
```

```hs
ghci> take 5 ones
[1,1,1,1,1]
```

## Полиморфизъм

Полиморфизмът ни позволява да пишем функции,
които работят върху класове от типове вместо
само един конкретен тип:

```hs
reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]
```

В горния пример се интересуваме единствено от структурата
на самия списък (т.е. празен или непразен), за да дефинираме
функцията. Очевидно няма значение какви са елементите -
можем да обърнем елементите на всеки един списък, понеже
работим със самата структура на списъка и не изискваме
някакви конкретни свойства на елементите в него.

`a` се нарича *типова променлива* и при извикването на функция
с конкретен тип се замества с този тип (подобно на шаблоните в C++).

Най-често ще видите типа на такава функция изписан по горния начин.
Но истината е, че Haskell интерпретира горния тип по следния начин:

```hs
-- това също е валиден синтаксис!
reverse :: forall a. [a] -> [a]
```

Тоест, функцията `reverse` е дефинирана за всеки тип, който в случая
означаваме с типовата променлива `a`.

Това е пример за т.нар. *параметричен полиморфизъм*.

Но да си представим, че искаме да напишем функция, която проверява
дали даден елемент се съдържа в някакъв списък:

```hs
elem :: forall a. a -> [a] -> Bool
elem x [] = False
elem x (y:ys) = x == y || elem x ys
```

Но горната дефиниция няма да сработи:

```
• No instance for ‘Eq a’ arising from a use of ‘==’
```

Това е, защото тук всъщност искаме едно конкретно свойство на елементите
в списъка - да са сравними помежду си (`x == y`). Но това очевидно не е вярно за всеки тип!
В този случай можем да ограничим множеството от типове, с които можем да заместваме
типовата променлива `a` при извикване на функцията чрез **ограничението** `Eq a`:

```hs
elem :: forall a. Eq a => a -> [a] -> Bool
elem = ...

-- или просто
elem :: Eq a => a -> [a] -> Bool
```

Четем горното: "за всички типове `a`, чиито елементи са сравними".

Тези *ограничения* ни дават т.нар. ad hoc полиморфизъм в Haskell.

## Типови псевдоними

Нека се върнем на една от функциите от първата седмица:

```hs
printStudent :: (String, String, String, Int) -> String
printStudent (name, fn, major, year) = ...  -- дефиницията е прекалено дълга ;(
```

Очевидно трите низа означават различни неща, респективно име, факултетен номер и специалност.
Но при подобен тип на функцията е вероятно да се объркаме, коя компонента на наредената четворка
какво означава. За целта можем да използваме т.нар. типови псевдоними (type aliases):

```hs
type Name = String
type FacultyNumber = String
type Major = String
type Year = Int
```

Тогава можем да напишем следното:

```hs
printStudent :: (Name, FacultyNumber, Major, Year) -> String
```

Забележете, че това са просто други имена за един и същи тип.
Тук **НЕ** създаваме нови типове.

## Алгебрични типове данни (АТД)

Досега сме използвали само вградените типове в Haskell - `Int`, `String`,
`(a,b)`, `[a]` и т.н. Естествено е да се запитаме дали ние сами 
можем да дефинираме нови типове.

Отговорът на горното е, че можем, използвайки т.нар. алгебрични типове данни
(algebraic data types).

Ще разгледаме два начина да направим това - `data` и `newtype`.

- ### `data`

  Това е основният начин да се дефинират по-сложни типове в Haskell.

  ```hs
  data Season = Spring | Summer | Autumn | Winter
  ```

  Горното е аналогично на `enum` в други езици и
  дефинира т.нар. изброим тип. Нарича се *сума* на типове.

  `Season` се нарича **типов конструктор**, а
  `Spring`, `Summer`, `Autumn`, `Winter` - **конструктори на данни**.
  В случая и двата вида конструктори са 0-местни, тъй като не приемат
  никакви аргументи.

  Тогава бихме могли да напишем следната функция:

  ```hs
  seasonToString :: Season -> String
  seasonToString Spring = "Spring"
  seasonToString Summer = "Summer"
  seasonToString Autumn = "Autumn"
  seasonToString Winter = "Winter"
  ```

  Това е т.нар. напасване на образци при АТД, подобно
  на числата, наредените n-торки и списъците. **Това е едно
  от най-мощните средства при работа с АТД.**

  Можем и да усложним типовете данни, използвайки
  т.нар. произведение на типове:

  ```hs
  data Person = Person String Int
  ```

  Тогава конструкторът на данни `Person` приема аргументи
  от два типа: `String` и `Int`, и е двуместен.

  Значи можем да напишем следните 2 проекции:

  ```hs
  getName :: Person -> String
  getName (Person name _) = name
  ```

  ```hs
  getAge :: Person -> Int
  getAge (Person _ age) = age
  ```

  Тук отново можем да използваме образци при конструкторите на данни.

  Забележете, че типовият конструктор и конструкторът на данни имат
  едно и също име - `Person`. Това не е проблем, тъй като следва да
  използваме всеки от тях в различен контекст - типовият конструктор
  се използва в типови функции (напр. `Person -> Int`), а този на данни -
  във функциите, които работят над данни, а именно - `getName` и `getAge`.

  Следващата секция е тук просто за ваше сведение, на това упражнение няма да
  се занимаваме с рекурсивни типове данни.

  Можем да създаваме и рекурсивни типове данни. В действителност ние вече познаваме
  един такъв рекурсивен тип данни - списъци. Даже бихме могли сами да си го дефинираме:

  ```hs
  data IntList = Nil | Cons Int IntList
  ```

  Тогава можем да дефинираме следната функция:

  ```hs
  reverseList :: IntList -> IntList
  reverseList = ... -- за упражнение я имплементирайте сами :)
  ```
  
  Но по-горе казахме, че бихме искали да пишем максимално общи (полиморфни) функции.
  Тогава бихме могли да направим самия АТД полиморфен чрез типова променлива:

  ```hs
  data List a = Nil | Cons a (List a)
  ```

  Други два често използвани АТД са `Maybe` и `Either`:

  ```hs
  data Maybe a = Nothing | Just a
  ```

  ```hs
  -- двуместен типов конструктор
  data Either a b = Left a | Right b
  ```

- ### `newtype`

  Всичко, което можем да дефинираме с `newtype`, можем да дефинираме и с `data`
  (обратното не е вярно). Тази секция отново е допълнение.

  `newtype` също позволява дефинирането на **нови** типове данни, но е по-ограничен
  от `data`. Понякога се описва като нещо средно между `type` и `data`.

  За `newtype` са характерни следните неща:
  - създава *нов* тип данни;
  - има единствен конструктор на данни;
  - конструкторът на данни е едноместен, т.е. приема единствен аргумент от даден тип.

  Например, бихме могли да дефинираме множество по следния (наивен) начин:

  ```hs
  newtype Set a = Set [a]
  ```

  `newtype` е т.нар. zero-cost abstraction. Това означава, че конструкторът на данни
  съществува само по време на компилация, но изчезва напълно по време на изпълнение на програмата.
  В този смисъл `newtype` създава някаква обвивка на даден тип по време на компилация, която подобрява
  четимостта и позволява този "нов тип" да се третира по различен начин от типа в самата обвивка.
  Пример за последното е именно множеството. Очевидно е, че сравняваме списъци и множества по различни начини,
  тъй като при списъците позицията и повторенията на елементите имат значение. Тогава можем да създадем различна
  инстанция на типовия клас `Eq` (т.е. да дефинираме оператора `==` по различен начин от този за списъци),
  която да уважава свойствата на множеството. Ще разгледаме накратко тези инстанции на типови класове по-напред
  в курса. Засега ще разгледаме само `deriving` синтаксиса.

## Record синтаксис

По-горе видяхме как можем да дефинираме проекции върху произведение на типове
(или по-познатите ви селектори) в лицето на `getName` и `getAge` за `Person`.
Haskell ни предоставя опцията автоматично да генерираме такива селектори
чрез т.нар. record синтаксис:

```hs
data Person = Person { getName :: String, getAge :: Int }
```

Тогава `getName` и `getAge` имат следните типове:

```hs
getName :: Person -> String
getAge :: Person -> Int
```

## Deriving синтаксис

По-нагоре разгледахме функцията `seasonToString`, която приема някакъв сезон и връща
низовото му представяне. В случая имаме само четири различни конструктора на данни,
така че не е толкова трудоемко да имплементираме такава функция ръчно. Но това невинаги би било така.
Затова Haskell ни предоставя начин, по който можем автоматично да генерираме такъв метод на
база имената на самите конструктори на данни:

```hs
data Season = Spring | Summer | Autumn | Winter
  deriving Show
```

Горният синтаксис `deriving Show` автоматично създава функция `show :: Season -> String` за нашия АТД.

Можем да направим същото за още няколко типови класа (`Show` е т.нар. типов клас):

  - `Read` - създава функция `read :: String -> a`, където `a` е типът на АТД;
  - `Eq` - създава функции `(==) :: a -> a -> Bool` и `(/=) :: a -> a -> Bool` за конкретен АТД;
  - `Ord` -  създава няколко функции, някои от които: `(<=) :: a -> a -> Bool`, `compare :: a -> a -> Ordering`,
    където `Ordering` също е АТД:

      ```hs
      data Ordering = LT | EQ | GT
      ```

    `Ord` дефинира *линейна* наредба.

  - `Enum` - създава функции като `succ :: a -> a`, `pred :: a -> a`, `fromEnum :: Int -> a`, `toEnum :: a -> Int`,
      които са възможни само за изброими типове (освен ако методите не се дефинират експлицитно, което ще правим по-нататък
      в курса);

  и др.

Например:

```hs
data Season = Spring | Summer | Autumn | Winter
  deriving (Read, Show, Eq, Ord, Enum)
```

```hs
fmtSeason :: Season -> String
fmtSeason s = "The current season is " ++ show s
```

```hs
nextSeason :: Season -> Season
-- този случай е необходим, понеже Winter е с последен индекс
-- при изброяването и ще върне грешка, а не - Spring
nextSeason Winter = Spring
nextSeason s = succ s
```

`read` основно се използва или в по-сложни полиморфни функции, или при входно-изходни операции.

За упражнение може сами да си създадете функции, които използват равенството и линейната наредба
при сезоните (основно защото не се сещам за достатъчно интересни примери :D).
