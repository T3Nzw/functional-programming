# Задачи

## Задача 01

Да се дефинира функция, която приема елемент от произволен тип
и връща безкраен списък, съдържащ този елемент:

Пример:

```hs
take 3 (repeat "hi")  -- ["hi", "hi", "hi"]
```

## Задача 02

Да се дефинира функция, приемаща цяло число `n` и генерираща безкраен
списък `[n, n+1, ..]`. За целта не използвайте генератор на списъци.

Пример:

```hs
take 10 (from 4) -- [4,5,6,7,8,9,10,11,12,13]
```

## Задача 03

Да се дефинира безкраен списък от числата на Фибоначи.

Пример:

```hs
take 10 fibs  -- [0,1,1,2,3,5,8,13,21,34]
```

## Задача 04

Да се дефинира алгебричен тип данни, представящ релации на наредба между елементи,
като за два елемента `x` и `y` е вярно, че:

- или `x < y`;
- или `x == y`;
- или `x > y`.

Да се дефинира функция, която сравнява два елемента от целочислен тип
и връща стойност от горния АТД.

```hs
cmpInt :: Int -> Int -> Ordering
```

Пример:

```hs
cmpInt 1 7  -- LessThan
cmpInt 7 7  -- Equal
cmpInt 7 1  -- GreaterThan
```

## Задача 05

Да се дефинира алгебричен тип данни, представящ фигура в равнината,
която може да бъде триъгълник, квадрат или правилен многоъгълник, представена
чрез броя страни, които има, и дължините на тези страни.
Да се дефинират следните функции:

- `perimeter :: Shape -> Double`;
- `numberOfSides :: Shape -> Int`;
- `prettyPrint :: Shape -> String`, където изходът трябва да е в следния формат:

  ```hs
  prettyPrint (Square 4)           ~> "This figure is a square with sides of length 4"
  prettyPrint (Triangle 4.5 1 3.6) ~> "This figure is a triangle with sides 4.5, 1, and 3.6"
  prettyPrint (Polygon 5 6.6)      ~> "This figure is a regular polygon that has 5 sides, each of length 6.6"
  ```

## Задача 06

Да се дефинира алгебричен тип данни, представящ наредена двойка,
където двете компоненти могат да бъдат от произволен тип.
Да се дефинират следните функции:

- `myFst :: Pair a b -> a`;
- `mySnd :: Pair a b -> b`;
- `myRev :: Pair a b -> Pair b a`;
- `pairToTuple :: Pair a b -> (a,b)`;
- `tupleToPair :: (a,b) -> Pair a b`;
- `cmpPair :: (Ord a, Ord b) => Pair a b -> Ordering`, където `Ordering` е АТД от задача 04;
- `pairsToList :: [Pair a b] -> Pair [a] [b]`.

## Задача 07

Да се дефинира алгебричен тип данни `Maybe`, аналогичен на този,
за който сте говорили на лекции. Да се дефинират следните функции:

- `safeDiv :: Double -> Double -> Maybe Double`;
- `addM :: Maybe Int -> Maybe Int -> Maybe Int`;
- `sumM :: [Maybe Int] -> Maybe Int`;
- `isJust :: Maybe a -> Bool`;
- `isNothing :: Maybe a -> Bool`;
- `fromJust :: Maybe a -> a`.

---

#### **Забележка:** За следващите задачи може ви ще ви бъде удобно да си дефинирате допълнителна функция, която сортира някакъв списък.

## Задача 08

Да се дефинира алгебричен тип данни, представящ множество от
елементи от произволен тип. Да се дефинират следните функции:

- `fromList :: [a] -> Set a`;
- `toList :: Set a -> [a]`;
- `insert :: a -> Set a -> Set a`;
- `delete :: a -> Set a -> Set a`;
- `elemS :: a -> Set a -> Bool`;
- `union :: Set a -> Set a -> Set a`;
- `intersect :: Set a -> Set a -> Set a`;
- `equal :: Set a -> Set a -> Bool`.

*Забележка*: Някои от типовете на горните функции са **непълни**.
Допълнете ги по такъв начин, че да се компилират и работят коректно.

## Задача 09

Да се дефинира алгебричен тип данни, представящ речник от ключове
и стойности, където всеки ключ е уникален. Да се дефинират следните функции:

- `fromList :: [(k,v)] -> Dict k v`;
- `toList :: Dict k v -> [(k,v)]`;
- `insert :: k -> v -> Dict k v -> Dict k v`;
- `delete :: k -> Dict k v -> Dict k v`;
- `lookup :: k -> Dict k v -> Maybe v`;
- `merge :: Dict k v -> Dict k v -> Dict k v`, която слива два речника така,
  че ако на един и същи ключ съответстват различни стойности, се избира тази
  от втория речник.

*Забележка*: Някои от типовете на горните функции са **непълни**.
Допълнете ги по такъв начин, че да се компилират и работят коректно.
