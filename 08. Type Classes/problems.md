# Задачи

## Задача 01
Да се дефинира типов клас `Sizeable`, който има единствен метод
`size :: a -> Int`. Да се създадат инстанции на класа `Sizeable`
за типовете `Int`, `Maybe a` и `[a]`.

## Задача 02

Да се дефинира алгебричен тип данни `Down`, който съдържа елемент от някакъв тип,
чиито елементи са сравними помежду си. Да се създаде инстанция на класа `Ord` за
типа `Down`, която "обръща" наредбата между елементите на типа, съдържащ се в `Down`.

## Задача 03

Нека е даден следния алгебричен тип данни за списък:

```hs
data List a = Nil | Cons a (List a)
```

Да се създадат инстанции на следните типови класове за типа `List`:

- `Monoid` - да се създаде overload на оператора `<>`, който "комбинира"
  две стойности от дадения тип;
- `Semigroup` - да се създадат **поотделно** overload-и на функциите
  `mempty` (неутрален елемент), `mappend` (комбиниране на две стойности)
  и `mconcat` ("сплесква" списък от стойности до една стойност, като ги комбинира);
- `Show` - форматира списъците по следния начин: `(x1,x2,...,xN)`;
- `Eq` - сравнява списъците поелементно;
- `Ord` - сравнява списъците лексикографски;
- `Foldable` - да се създаде overload на функцията `foldr`;
- `Functor` - да се създаде overload на функцията `fmap` (подобно на `map` за вградените списъци).

*Бонус*: Напишете свои имплементации на горните типови класове.

## Задача 04

Да се дефинира типов клас `Stream`, който обобщава операциите,
които можем да извършваме над даден "поточен тип", независимо от
елементите в него. Бихме искали да обобщим операциите за взимане
на празен поток (`empty`), добавянето на елемент в началото на поток
(`cons`) и взимането на първия елемент в непразен поток (`uncons`).

*Забележка*: Горният типов клас е много полезен при параметризирането
на т.нар. parser комбинатор по типа на потока, от който чете.
Този подход се използва от големите библиотеки за parser комбинатори,
напр. `parsec`, `megaparsec`, `attoparsec` и др.
В бъдещи упраженения ще разгледаме как се дефинира такъв комбинатор (сравнително прост).
Такова параметризиране се прави с цел обобщение на този поток -
това е полезно, ако искаме да използваме `ByteString` (ASCII низ) или `Text`
(UTF-8 низ), чиито имплементации са по-оптимални от тази на `String`.
Друг вид поток, за който горната абстракция би била полезна, е поток от жетони
(tokens), който би генерирал лексичният анализатор за даден език. Тогава такъв
поток би могъл да бъде входен за синтактичния анализатор за същия език (ако
разделяме лексичния и синтактичния анализ, честа практика в Haskell е да се
използва т.нар. комбиниран синтактичен анализ, където директно комбинараме
двете фази).

## Задача 05

Нека е даден следния алгебричен тип за двоично дърво:

```hs
data BinTree a = Empty | Node a (BinTree a) (BinTree a)
  deriving (Show, Eq)
```

Да се създадат инстанции на типовите класове `Functor` и `Foldable` за типа `BinTree`.

## Задача 06

Нека е даден следния типов клас:

```hs
class Brzozowski r where
  nullable :: r a -> Bool
  derivative :: Eq a => a -> r a -> r a
```

и следните две дефиниции на АТД:

```hs
data DFA s a = DFA
  { start :: s
  , delta :: s -> a -> s
  , accept :: [s]
  }
```

```hs
data Regex a
  = REmpty
  | Epsilon
  | Atom a
  | KStar (Regex a)
  | Regex a :+ Regex a  -- обединение на регулярни изрази
  | Regex a :. Regex a  -- конкатенация на регулярни изрази
```

Да се създадат инстанции на класа `Brzozowski`, представящ производни
на Бжозовски, за двата типа данни `DFA` и `Regex`.
