# Списъци - 14.10.2025

## Рекурсия

Рекурсията е основният начин да решаваме по-интересни и сложни
задачи в контекста на функционалното програмиране, тъй като
липсват итеративни процеси (макар че в определени ситуации
на по-ниско ниво рекурсивните процеси се оптимизират до итеративни такива).

```hs
factorial :: Int -> Int
factorial 0 = 1 -- дъно на рекурсията
factorial n = n * factorial (n - 1)
```

## Списъци

Списъците в Haskell са реализирани чрез линейни едносвързани списъци.
Това ни позволява да разделим всеки непразен списък на "глава" (head),
която е някакъв елемент на списъка, и "опашка" (tail), която представлява
списъка без първия му елемент. Затова следните записи са еквивалентни:

```hs
[1,2,3] == 1:[2,3] == 1:2:[3] == 1:2:3:[]
```

където `(:) :: a -> [a] -> [a]` е оператор,
който взима елемент от някакъв тип и списък
от елементи от този тип и връща нов списък,
където този елемент е долепен в началото на
стария списък.

`head :: [a] -> a` и `tail :: [a] -> [a]` са
вградени функции, които разделят списък по
горния начин:

```hs
ghci> head [1,2,3]
1
ghci> tail [1,2,3]
[2,3]
```

Други оператори и функции, работещи със списъци, са:

- `(++) :: [a] -> [a] -> [a]` - слепва два списъка;
- `(!!) :: [a] -> Int -> a` - връща елемента на даден индекс в подадения списък;
- `length :: [a] -> Int` - връща дължината на списък;
- `init :: [a] -> [a]` - връща списък без последния му елемент;
- `last :: [a] -> a` - връща последния елемент на списък;
- `reverse :: [a] -> [a]` - обръща списък;
- `take :: Int -> [a] -> [a]` - за естествено число `n` и списък `lst` връща списък с първите `n` елемента от `lst`;
- `drop :: Int -> [a] -> [a]` - за естествено число `n` и списък `lst` връща списък без първите `n` елемента от `lst`;
- `elem :: Eq a => a -> [a] -> Bool` - връща дали някакъв елемент се среща в дадения списък;

и др.

### Образци при списъци

Подобно на образците, които можем да използваме в контекста на числа и наредени n-торки,
имаме и образци, които работят със списъци:

```hs
length :: [a] -> Int
length [] = 0
length (x:xs) = 1 + length xs
```

### Генератори на списъци

В Haskell имаме лесен начин за генериране на списъци от последователни елементи в
някакъв интервал, чийто синтаксис изглежда по следния начин:

```hs
[1..10]     -- [1,2,3,4,5,6,7,8,9,10]
['a'..'z']  -- латинските букви от a до z
[5,3..-5]   -- [5,3,1,-1,-3,-5]
```
