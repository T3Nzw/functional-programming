# Задачи

## Задача 00

Дефинирайте свои варианти на типовите класове за функтор,
апликативен функтор и монада. Допълнително дефинирайте
метода `liftA2 :: (a -> b -> c) -> f a -> f b -> f c`
за класа `Applicative`, използвайки другите му два метода.

За следващите задачи (без задача 09) използвайте именно тези дефиниции.

## Задача 01

Създайте инстанции на горните типови класове за типа данни
`Maybe`. Очакваме следното поведение за отделните методи:

```hs
ghci> fmap (+1) (Just 1)
Just 2
ghci> (pure 1) :: Maybe Int
Just 1
ghci> (pure $ \x -> x + 1) <*> Just 2
Just 3
ghci> liftA2 (+) (Just 5) (Just 6)
Just 11
ghci> (return $ 15 - 13) :: Maybe Int
Just 2
ghci> Just 1 >>= \x -> return (x * 12)
Just 12
```

## Задача 02

Създайте инстанции на горните типови класове за типа данни
`Either`. Очакваме следното поведение за отделните методи:

```hs
ghci> fmap (++ "!") $ Right "Hello"
Right "Hello!"
ghci> fmap (++ "!") $ Left "Hello."
Left "Hello."
ghci> Right (*10) <*> Right 15
Right 150
ghci> Left "error" >>= pure . (^2)
Left "error"
```

## Задача 03

Да се дефинират алгебричните типове данни `Sum` и `Product`
и да се създадат инстанции на класа `Monoid`.

Да се създадат инстанции на класовете `Functor`,
`Applicative`, `Monad` за горните два АТД.

```hs
ghci> fmap (+1) (Sum 1)
Sum 2
ghci> (pure 4) :: Product Int
Product 4
ghci> mempty >>= ((<> Sum 3) . return)
Sum 3
```

## Задача 04

Създайте инстанции на горните типови класове за типа данни
`List a` от миналия път. Имайте предвид, че списъците задават
недетерминизъм при изчисленията, които кодираме.

Например, вграденият тип `[a]` работи по следния начин:

```hs
ghci> fmap (*2) [1,2,3]
[2,4,6]
ghci> (pure "abcd") :: [String]
["abcd"]
ghci> pure (subtract 1) <*> [1,2,3]
[0,1,2]
ghci> [(+1), (*2)] <*> [1,2]
[2,3,2,4]
ghci> [1,2,3] >>= \x -> [x,-x]
[1,-1,2,-2,3,-3]
```

## Задача 05

Дефинирайте типовия клас `Bifunctor`, подобен на `Functor`,
който обаче разполага с две функции, които да прилага върху две
различни стойности.

Създайте инстанции на типовете данни `Either` и `(,)` (наредена двойка)
за типовия клас `Bifunctor`:

```hs
ghci> bimap (*10) (*20) $ Left 3
Left 30
ghci> first (+10) $ Right 3
Right 3
ghci> bimap (+2) ((subtract $ ord '0') . ord) (3,'7')
(5,7)
ghci> second ("Hi " ++) ((), "there")
((), "Hi there")
```

Каква е разликата между `liftA2` за апликативните функтори
и `bimap` за бифункторите?

## Задача 06

Създайте инстанции на типовите класове `Functor`, `Applicative`
и `Monad` за вградения тип за наредени двойки. Какъв проблем
виждате?

```hs
ghci> fmap (+1) (1,2)
(1,3)
ghci> (return "xyz") :: (?,String)
(?,"xyz")
ghci> (Just [12], "abcd") >>= pure . fmap (chr . (+ 1) . ord)
(Just [12], "bcde")
```

По какъв начин бихме могли да фиксираме втория аргумент, така че
да получим следното поведение:

```hs
ghci> fmap (+1) (1,2)
Just (2,2)
```

## Задача 07

Създайте инстанции на типовите класове `Functor`, `Applicative`
и `Monad` за типовия конструктор `(->)`, където първият
типов параметър е фиксиран.

```hs
ghci> :t fmap even (+1)
fmap even (+1) :: Integral a => a -> Bool
ghci> :t (pure 7) :: (() -> Int)
(() -> Int)
ghci> ((pure 7) :: (() -> Int)) ()
7
```

Бихме ли могли да фиксираме втория аргумент на типовия конструктор `(->)`?
Това функтор ли ще бъде? Защо?

## Задача 08

Нека е дадена следната дефиниция на алгебричен тип данни:

```hs
newtype State s a = State {runState :: s -> (a, s)}
```

който приема тип на състояние `s` и резултат от изчисление `a`.
Да се създадат инстанции на типовите класове `Functor`, `Applicative`
и `Monad` за `State s`, където типът на състоянието е фиксиран (защо?).

## Задача 09

Използвайки State монадата от задача 08, напишете функция,
реализираща алгоритъма за обхождане в дълбочина за граф.

Граф ще представяме чрез следния алгебричен тип данни:

```hs
data AdjacencyList a = AList
  { _value :: a,
    _adjacent :: [a]
  }
  deriving (Show, Eq, Ord)

newtype Graph a = Graph [AdjacencyList a]
  deriving (Show, Eq, Ord)
```
