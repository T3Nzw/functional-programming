# Въведение във функционалното програмиране и Haskell

## Езикът `Haskell`

Накратко за Haskell:

  - функционален език за програмиране;
  - *статично* и *силно* типизиран;
  - използва *лениво* оценяване (lazy evaluation); нарича се още *нормална* стратегия на оценяване;
  - променливите са *неизменяеми* (immutable) по подразбиране;
  - функциите са *чисти* (pure), т.е. нямат *странични ефекти* (side effects).

По-нататък в курса ще се запознаем със **Scheme** - функционален език,
който, за разлика от Haskell, е *динамично* типизиран и оценяването
в който се извършва *строго* (strict evaluation).

### Типове данни

- `Int` - цяло число в интервала [-9223372036854775808, 9223372036854775807]
- `Integer` - цяло число с произволна големина; по-неоптимално спрямо `Int`
- `Float` - дробно число с единична прецизност
- `Double` - дробно число с двойна прецизност
- `Bool` - булева стойност
- `Char` - UTF8 символ
- `String` - низ; същото е като списък от символи `[Char]`
- `[Int]`, `[Char]`, `[Integer]`, `[[Int]]`, `...` - списъци
- `(Int, Char)`, `(Int, Int, Int)`, `...` - наредени n-торки

и други, за които ще говорим по-нататък.

### Аритметични оператори и функции

- `+`, `-`, `*`, `/`, `^`, `div`, `quot`, `rem`, `mod`, `negate`, `abs`, `signum`, `fromIntegral`, ...

*Съвет*: За да видите повече информация за дадената функция,
може да напишете `:i(nfo) <function>` в GHCi. 

### Логически оператори

- `<`, `>`, `<=`, `>=`, `==`, `/=`, `&&`, `||`

*Забележка*: Няма оператор за отрицание `!`. За целта се използва функцията `not`.

### Функции

Всяка функция приема `n` на брой аргументи и връща някакъв резултат.
От това следва, че и типът на дадена функция се състои от тези 
`n+1` на брой типа, разделени със стрелки `->`:

```hs
add :: Int -> Int -> Int  -- тип на функция
add x y = x + y  -- дефиниция на функцията
```

```hs
функция :: Float -> String
функция _ = "Можем да използваме кирилица!"
```

```hs
greet :: String -> String  
greet name = "Hello, " ++ name
```

```hs
-- това е т.нар. параметричен полиморфизъм в Haskell.
-- очевидно функцията не зависи от това, какъв тип
-- са елементите на списъка, така че можем да направим
-- функцията полиморфна чрез заместването на конкретен тип
-- с типова променлива - a
reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]
```

```hs
-- Eq a не е тип! по-нататък ще разберем какво прави,
-- засега е тук само с демонстративна цел :)
fixpoint :: Eq a => (a -> a) -> a -> a
fixpoint f x
  = if f x == x
      then x
      else fixpoint f (f x)
```

В частност, можем да си мислим за променливите `foo :: Int`
като за 0-местни функции.

### Условни конструкции

- if/else
```hs
length :: [a] -> Int
length l
  = if null l
      then 0
      else 1 + length (tail l)
```

- guards
```hs
length :: [a] -> Int
length l
  | null l    = 0
  | otherwise = 1 + length (tail l)
```

- pattern matching
```hs
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs
```

- cases (реално също е вид pattern matching)
```hs
length :: [a] -> Int
length l
  = case l of
      [] -> 0
      (_:xs) -> 1 + length xs
```

## Where клаузи и let-bindings

И двете са начин да пишем локални дефиниции
в областта на някаква друга дефиниция:

```hs
foo :: Int -> Int
foo n = bar + baz * qux
  where
    bar = n * 10 + 20
    baz = n ^ 2
    qux = bar + baz
```

```hs
foo :: Int -> Int
foo n = let bar = n * 10 + 20
            baz = n ^ 2
            qux = bar + baz
          in bar + baz * qux
```

Забележете, че идентацията в горните примери *има значение*.
